# feat(tg-bot): concurrent updates, per-chat queue, SessionDB lock

## Что сделано

1. **Бот отвечает во время выполнения задачи**  
   Включён `concurrent_updates(True)` — команды `/status`, `/tasks`, `/help` и новые сообщения обрабатываются без ожидания завершения текущей задачи.

2. **Очередь по чату**  
   Для каждого `chat_id` свой `asyncio.Lock`. Две задачи из одного чата выполняются строго по очереди (вторая ждёт окончания первой). Разные чаты обрабатываются параллельно.

3. **Статус в командах**  
   - `/status`: отображает «N running, M queued».  
   - `/tasks`: список выполняющихся задач + по чатам с очередью «Chat X: N queued».

4. **Защита SessionDB от гонок**  
   В `get_model_message_history`, `set_model_message_history`, `get_session`, `get_messages`, `get_recent_messages` все обращения к БД обёрнуты в `async with self._lock` для согласованных чтений/записей при параллельных задачах.

5. **Panic**  
   Очищаются `_active_tasks` и `_chat_queued_count` (отображение; сами корутины не отменяются).

## Тесты

- `test_session_db_concurrency.py` — параллельные read/write под локом SessionDB.
- `test_telegram_queue.py` — сериализация по chat lock, счётчик queued, декремент при исключении до захвата лока.
- `test_telegram_two_tasks_same_chat.py` — два сообщения в одном чате выполняются по порядку, ответы в том же порядке.
- `test_telegram_status_tasks.py` — в выводе `/status` и `/tasks` есть running/queued и початовые очереди.

**109 тестов проходят** (без `test_agent_capabilities.py`).
